<html>
    <head>
        <meta charset='UTF-8'/>
        <title>Basic Shader Particles</title>
        <link rel="stylesheet" type="text/css" href="./css/style.css">
    </head>
    <body>
        <select id="n">
            <option value="0">0</option>
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
        </select>
        
        <p class="numParticles"></p>

        <!-- THREE.min.js r60 and FPS stats -->
        <script type="text/javascript" src="./js/THREE-r65.min.js"></script>
        <script type="text/javascript" src="./js/Stats.min.js"></script>
        <script type="text/javascript" src="js/OrbitControls.js"></script>

        <!-- ShaderParticles -->
        <script type="text/javascript" src="js/MathLib/MathLib.js"></script>
        <script type="text/javascript" src="js/MathLib/Complex.js"></script>
        <script type="text/javascript" src="js/MathLib/Laguerre.js"></script>
        <script type="text/javascript" src="js/MathLib/AssocLegendre.js"></script>
        <script type="text/javascript" src="js/MathLib/SphericalHarmonic.js"></script>

        <script type="text/javascript" src="../src/ShaderParticleUtils.js"></script>
        <script type="text/javascript" src="../src/ShaderParticleGroup.js"></script>
        <script type="text/javascript" src="../src/ShaderParticleEmitter.js"></script>


        <script type="text/javascript">

            function Ψ(n, l, m) {
                var a0 = 50; // bohr radius

                this.n = n;
                this.l = l;
                this.m = m;
                this.const = Math.sqrt(
                        (2 / n / a0) * (2 / n / a0) * (2 / n / a0) *
                        MathLib.factorial(n - l - 1) /
                        (2 * this.n * MathLib.factorial(n + l))
                        );
                var opts = {
                    lag: new Laguerre(n - l - 1, 2 * l + 1),
                    shr: new SphericalHarmonic(l, m),
                    eval: function(r, θ, φ) {
                        return this.const * this.evalRad(r) * this.evalAng(θ, φ);
                    },
                    evalRad: function(r) {
                        var ρ = 2 * r / (this.n * a0);
                        return Math.abs(Math.exp(-ρ / 2) * Math.pow(ρ, this.l) * this.lag.eval(ρ));
                    },
                    evalAng: function(θ, φ) {
                        return this.shr.eval(θ, φ).length();
                    }
                };
                extend(this, opts);
                return this;
            }


            function randBtw(a, b) {
                return (b - a) * Math.random() + a;
            }

            function randBtwVect(v1, v2) {
                return new THREE.Vector3(randBtw(v1.x, v2.x), randBtw(v1.y, v2.y), randBtw(v1.z, v2.z));
            }

            var rmin = 0,
                    rmax = 2000,
                    incr = 50;
            var tmin = 0,
                    tmax = 2 * Math.PI,
                    tincr = Math.PI/30;

            var angular = (function() {
                var data = [];
                for (var theta = tmin; theta < tmax; theta += tincr) {
                    for (var phi = tmin; phi < tmax; phi += tincr) {
                        data.push(new THREE.Vector2(theta, phi));
                    }
                }
                return data;
            })();

            var radial = (function() {

                var data = [];

                for (var r = rmin; r < rmax; r += incr) {
                    data.push(r);
                }
                return data;
            })();



// variables used in init()
            var scene, camera, renderer, clock;
// Used in initParticles()
            var emitter, particleGroup, numEmitters = 1;
// Setup the scene
            function init() {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100000);

                camera.lookAt(scene.position);
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000000);
                clock = new THREE.Clock();
                document.body.appendChild(renderer.domElement);
            }

            function getRandomNumber(base) {
                return base * Math.random() - (base / 2);
            }

// Create particle group and emitter
            function initParticles() {
                particleGroup = new SPE.Group({
                    texture: THREE.ImageUtils.loadTexture('./img/particle3.png'),
                    maxAge: 2
                });
                for (var i = 0; i < numEmitters; ++i) {
                    emitter = new SPE.Emitter({
                        type: 'function',
                        func: new Ψ(6, 5, 1), //n,l,m
                        positionGrid: (function() {

                            var grid = [];

                            for (var r = rmin; r < rmax; r += incr) {
                                for (var theta = tmin; theta < tmax; theta += tincr) {
                                    for (var phi = tmin; phi < tmax; phi += tincr) {
                                        grid.push(new THREE.Vector3(r, theta, phi));
                                    }
                                }
                            }
                            return grid;
                        })(),
                        increment: incr,
                        sizeStart: 20,
                        radius: 10,
                        particleCount: Math.floor((rmax - rmin) / incr) * Math.floor((tmax - tmin) / tincr) * Math.floor((tmax - tmin) / tincr),
                        colorStartSpread: new THREE.Vector3(1, 1, 1),
                        opacityStart: 1,
                        opacityEnd: 0,
                        isStatic: 1
                    });
                    emitter.tincr = tincr;
                    particleGroup.addEmitter(emitter);
                }

                scene.add(particleGroup.mesh);

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                camera.position.z = rmax * 1.5;
                camera.position.y = 0;
                camera.position.x = 0;
                controls.addEventListener('change', render);
            }

            function setCount(count) {
                document.querySelector('.numParticles').textContent = 'Total particles: ' + count;
            }

            function animate() {
                requestAnimationFrame(animate);
                // Using a fixed time-step here to avoid pauses
                render(clock.getDelta());
            }


            function render(dt) {
                //particleGroup.tick(dt);
                renderer.render(scene, camera);
            }


            SPE.ready(function() {
                init();
                initParticles();
                animate();

                window.addEventListener('resize', function() {
                    var w = window.innerWidth,
                            h = window.innerHeight;
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                    renderer.setSize(w, h);
                }, false);
                
                document.getElementById('n').addEventListener('change', function(e){
                    console.log(emitter.func.n);
                    emitter.func.n = +this.value;
                });
                
            }
            );


        </script>

    </body>
</html>